import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db/prisma";
import { getCurrentUser } from "@/lib/auth";
import { SMTPClient } from "@/lib/email/smtp-client";
import { generateEmailContent, textToHtml } from "@/lib/email/email-templates";
import { createErrorResponse, createUnauthorizedResponse } from "@/lib/errors";
import { logInfo, logError, logWarn } from "@/lib/logging";
import { z } from "zod";
import { applyDataToBlocks } from "@/lib/template-utils";
import { pdf } from "@react-pdf/renderer";
import { TemplatePDF } from "@/lib/pdf/template-pdf";

const batchSendSchema = z.object({
    batchData: z.array(z.record(z.string(), z.any())),
    documentType: z.string().optional(),
    period: z.string().optional(),
});

export async function POST(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    try {
        const { context, error } = await getCurrentUser();
        const { id: templateId } = await params;

        if (!context) {
            logWarn("Failed to send batch emails: unauthorized", {
                action: "batch_send_emails",
            });
            return createUnauthorizedResponse(error || "Unauthorized");
        }

        // Parse and validate request body
        const body = await request.json();
        const validated = batchSendSchema.parse(body);

        // Get template
        const template = await prisma.template.findFirst({
            where: {
                id: templateId,
                organizationId: context.currentMembership.organization.id,
            },
        });

        if (!template) {
            return NextResponse.json({ error: "Template not found" }, { status: 404 });
        }

        // Get SMTP configuration
        const smtpConfig = await prisma.sMTPConfiguration.findUnique({
            where: {
                organizationId: context.currentMembership.organization.id,
            },
            include: {
                provider: true,
            },
        });

        if (!smtpConfig) {
            return NextResponse.json(
                { error: "Email configuration not found. Please set up SMTP in Settings." },
                { status: 400 }
            );
        }

        // Validate that all records have an Email field
        const recordsWithoutEmail = validated.batchData.filter((record) => !record.Email);
        if (recordsWithoutEmail.length > 0) {
            return NextResponse.json(
                {
                    error: `${recordsWithoutEmail.length} record(s) are missing an Email field`,
                },
                { status: 400 }
            );
        }

        // Initialize SMTP client
        const smtpClient = new SMTPClient({
            smtpServer: smtpConfig.provider.smtpServer,
            smtpPort: smtpConfig.provider.smtpPort,
            useTLS: smtpConfig.provider.useTLS,
            senderEmail: smtpConfig.senderEmail,
            senderName: smtpConfig.senderName,
            smtpUsername: smtpConfig.smtpUsername,
            smtpPassword: smtpConfig.smtpPassword,
        });

        // Connect to SMTP server
        const connectResult = await smtpClient.connect();
        if (!connectResult.success) {
            return NextResponse.json(
                { error: `Failed to connect to email server: ${connectResult.message}` },
                { status: 500 }
            );
        }

        // Send emails with PDFs
        let sent = 0;
        let failed = 0;
        const errors: Array<{ email: string; error: string }> = [];

        for (const record of validated.batchData) {
            try {
                // Generate PDF for this record
                const substitutedBlocks = applyDataToBlocks(
                    template.schema.blocks as any,
                    record
                );

                const pdfDocument = (
                    <TemplatePDF
                        blocks={substitutedBlocks }
                globalStyles={template.schema.globalStyles as any }
                paperSize={template.paperSize }
                orientation = { template.orientation }
                    />
                );

                const pdfBlob = await pdf(pdfDocument).toBlob();
                const pdfBuffer = Buffer.from(await pdfBlob.arrayBuffer());

                // Generate email content
                const recipientName = record.Name || record.Email.split("@")[0];
                const emailContent = generateEmailContent(
                    smtpConfig.emailSubject,
                    smtpConfig.emailBody,
                    {
                        recipientName,
                        documentType: validated.documentType || "Document",
                        period: validated.period || "current period",
                        organizationName: context.currentMembership.organization.name,
                    }
                );

                // Send email
                const emailResult = await smtpClient.sendEmail({
                    to: record.Email,
                    subject: emailContent.subject,
                    text: emailContent.body,
                    html: textToHtml(emailContent.body),
                    attachments: [
                        {
                            filename: `${template.name}-${recipientName}.pdf`,
                            content: pdfBuffer,
                            contentType: "application/pdf",
                        },
                    ],
                });

                if (emailResult.success) {
                    sent++;
                } else {
                    failed++;
                    errors.push({
                        email: record.Email,
                        error: emailResult.message,
                    });
                }
            } catch (error) {
                failed++;
                errors.push({
                    email: record.Email,
                    error: error instanceof Error ? error.message : "Unknown error",
                });
            }
        }

        // Disconnect from SMTP server
        await smtpClient.disconnect();

        logInfo("Batch emails sent", {
            userId: context.user.id,
            organizationId: context.currentMembership.organization.id,
            templateId,
            sent,
            failed,
            action: "batch_send_emails",
        });

        return NextResponse.json({
            success: true,
            sent,
            failed,
            total: validated.batchData.length,
            errors,
        });
    } catch (error) {
        if (error instanceof z.ZodError) {
            return NextResponse.json(
                { error: "Validation failed", details: error.issues },
                { status: 400 }
            );
        }

        logError(
            "Failed to send batch emails",
            error instanceof Error ? error : new Error(String(error)),
            { action: "batch_send_emails" }
        );
        return createErrorResponse(error, "Failed to send batch emails", 500);
    }
}
